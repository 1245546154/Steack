openstack的冷迁移和热迁移

CMDB

虚拟机交付方式困难，时间成本高，占用空间高，传输慢；想使用
操作系统内核需要进行2层调度

容器：Container  经过一定的技术手段做了一个隔离的空间
（能没有操作系统的情况下，实现隔离）
部署一种引擎，将虚拟机的操作系统去掉，还能实现操作系统的隔离


NameSpace――名称空间（需要隔离）
1.UTS    主机名和域名的隔离
2.IPC    进程间通讯的隔离
3.Mount  挂载的文件系统隔离
4.Net    网络隔离
5.User   用户隔离
6.PID    每个进程的PID隔离


LXC――Linux container   对使用容器这种方式隔离出来的空间进行管理和使用
它会创建NameSpace和创建你所使用的文件系统
缺点：在创建容器的过程中速度会慢，使用起来效率不是很高

Docker对LXC进行了二开增强，并开源了出来
docker是LXC的增强版
方便的地方在于：创建文件系统的速度比LXC速度快(它使用了文件系统镜像来
创建文件系统)

pam是对用户进行限制的，cgroup是对进程进行限制的，因此对超级用户运行的进程也一样
cgroup将cpu分为1024份，将IO带宽划分为1024

OOM：out of memory 内存溢出

容器资源限制的方式：cgroup
限制有两种方式：手动――，自动分配――

1.先创建一个cgroup，定义相应的限制，
2.然后将要限制的进程丢到这个限制组内执行


cpu有时间分片，内存有大小分片，磁盘有IO速度


cgexec -g 限制类型：限制组 命令
-g：指定资源组 


联合文件系统：是一种轻量级的高性能分层文件系统，组织文件的
存放的一种方式，每次提交都是在原来的层上面再加一层，原来的
层无法改动
image：镜像  （可以拖过去直接用的模板文件系统）
底层的模板是镜像，不能写入
上面启动的可写层，是容器


基础镜像：一般都是操作系统，用来生成其他镜像，没有父镜像

容器缺点：制作成的镜像无法改动，只能重新创建新的镜像来替换

cifs：通用的互联网文件系统


网络虚拟化：
容器有自己的虚拟网口，由DHCP分配IP地址，而且可能会不断发生变
化，对运维来说很困难
在docker上有网桥，只能工作在二层，无法划分不同网络，连接的
不同容器使用的是同一个网段


镜像仓库：存放镜像的库，一套全局及本地容器注册表


rancher系统

etcd：服务发现和服务注册的

flannel：跨主机容器间的通讯


docker是容器管理的一种实现
微服务架构


容器批量编排工具：实现容器的批量管理和批量编排
1.docker machine
2.docker compose
3.docker swarm
4.kubernetes          k8s
5.mesos（资源管理）+marathon（编排）





pacemaker  云系统高可用





























