容器就是容器，docker就是docker  

虚拟机交付方式困难，时间成本高，占用空间高，传输慢；想使用
操作系统内核需要进行2层调度


容器：Container  经过一定的技术手段做了一个隔离的空间
（能没有操作系统的情况下，实现隔离）
部署一种引擎，将虚拟机的操作系统去掉，还能实现操作系统的隔离


打包成模板文件（镜像）   
底层镜像（模板）为只读  
（可写层）可以启动那层叫容器  


如果想启动一个容器，直接将模板拖拽过去即可。

容器的模板，从下往上叠加，一层比一层高   


LXC――Linux container   对使用容器这种方式隔离出来的空间进行管理和使用
它会创建NameSpace和创建你所使用的文件系统
缺点：在创建容器的过程中速度会慢，使用起来效率不是很高





容器：Container  经过一定的技术手段做了一个隔离的空间
部署一种引擎，将虚拟机的操作系统去掉，还能实现操作系统的隔离

NameSpace――名称空间（需要隔离）
1.UTS    主机名和域名的隔离
2.IPC    进程间通讯的隔离
3.Mount  挂载的文件系统隔离
4.Net    网络隔离
5.User   用户隔离
6.PID    每个进程的PID隔离




――――――――――――――――――――――――――――――――――――――――――――――――――――――――――



对容器进行限制：
pam是对用户进行限制的
cgroup是对进程进行限制的，因此对超级用户运行的进程也一样

cgroup将cpu分为1024份，将IO带宽划分为1024
cpu有时间分片




容器资源限制的方式：cgroup
限制有两种方式：手动――，自动分配――

1.先创建一个cgroup，定义相应的限制          /etc/cgconfig.conf 或  /etc/cgconfig.d/cgroup.conf
2.然后将要限制的进程丢到这个限制组内执行

内存有大小分片，磁盘有IO速度 
 OOM： 内存溢出





――――――――――――――――――――――――――――――――――――――――――――――――――――――――――



网络虚拟化：

1.容器有自己的虚拟网口，由DHCP分配IP地址，而且可能会不断发生变
化，对运维来说很困难

2.在docker上有网桥，只能工作在二层，无法划分不同网络，连接的

3.不同容器使用的是同一个网段






主机虚拟化：

1.虚拟机交付方式困难，时间成本高，占用空间高，传输慢；想使用
操作系统内核需要进行2层调度


2.使用容器，将所有的软件和需要部署的程序都直接放到容器内，直接部署给开发人员即可。
只需要进行1层调度



将服务做模块化分配，使用联合文件系统，最底层的镜像至上做部署。（高内聚 低耦合）



如果想管理容器，应该怎么管理，使用docker或者LXC

chroot保护系统安全性与selinux保护系统安全性同理
linux安全模块，能够确保来自容器的主机设备和内核访问行为受到妥善管理

windows内部已经加入了linxu内核，但在容器里面最好不要去运行windows 
API：应用访问接口   

如果想运行容器，必须要先执行docker demon



――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
容器 & 镜像 & 仓库



每个容器只运行一个应用程序


运行一条命令，肯定是在容器里面运行的。
真实机没有容器
执行一条命令的时候，会产生一个容器，每次执行命令都会产生新的容器。


^^^容器不能做数据持久化，不能把数据存在容器里


